#include <string>
#include <fstream>
#include <dirent.h>
#include <errno.h>

#include <iostream>
#include <iomanip>
#include <ctime>
#include <sstream>

#include <ros/ros.h>
#include <tf/transform_broadcaster.h>
#include <tf/transform_listener.h>
#include <tf/transform_datatypes.h>
#include <Eigen/Geometry>
#include <tf_conversions/tf_eigen.h>

void saveTF(const tf::StampedTransform& transform, const std::string& filepath)
{
  std::ofstream calib_file;
  calib_file.open(filepath.c_str());
  ROS_INFO_STREAM("Saving transform from " << transform.frame_id_ << " to " << transform.child_frame_id_ << " in " << filepath);
  calib_file << "# This file was generated by kuka_calib\n# Transform between the world frame to the camera link\n# Position\n"
             << "export base_cam_x_pos=" << transform.getOrigin()[0] << "\n"
             << "export base_cam_y_pos=" << transform.getOrigin()[1] << "\n"
             << "export base_cam_z_pos=" << transform.getOrigin()[2] << "\nRotation\n"
             << "export base_cam_x_rot=" << transform.getRotation().x() << "\n"
             << "export base_cam_y_rot=" << transform.getRotation().y() << "\n"
             << "export base_cam_z_rot=" << transform.getRotation().z() << "\n"
             << "export base_cam_w_rot=" << transform.getRotation().w() << "\n";
}

int main(int argc, char** argv)
{
  // Define ROS info
  ros::init(argc, argv, "extrinsic_calibration");
  ros::NodeHandle nh;
  static tf::TransformBroadcaster camera_broadcaster;
  static tf::TransformBroadcaster target_broadcaster;
  static tf::TransformListener listener;

  // Get ROS params
  double targ_x, targ_y, targ_z;
  int num_iterations;
  std::string calibration_frame;
  std::string camera_link;
  std::string calib_dir;
  int cam_num;
  std::string ros_node_name=ros::this_node::getName();
  nh.param<double>("/" + ros_node_name + "/targ_x", targ_x, 0.0);
  nh.param<double>("/" + ros_node_name + "/targ_y", targ_y, 0.0);
  nh.param<double>("/" + ros_node_name + "/targ_z", targ_z, 0.0);
  nh.param<int>("/" + ros_node_name + "/num_iterations", num_iterations, 60);
  nh.param<std::string>("/" + ros_node_name + "/calibration_frame", calibration_frame, "calibration_frame");
  nh.param<std::string>("/" + ros_node_name + "/camera_link", camera_link, "camera_link");
  nh.param<std::string>("/" + ros_node_name + "/calib_dir", calib_dir, "calib_dir");
  nh.param<int>("/" + ros_node_name + "/cam_num", cam_num, 1);

  DIR* dir = opendir(calib_dir.c_str());
  if (dir)
  {
    /* Directory exists. */
    closedir(dir);
  }
  else
  {
    ROS_ERROR_STREAM(calib_dir << " does not exist.");
    return 1;
  }

  // File to save output transformation to
  std::string calib_file = calib_dir + "/base_cam_calib.sh";

  // Get transform from frame we want to output transform to and calibration frame before we mess up the TF tree
  tf::StampedTransform camlink2calib;
  listener.waitForTransform(camera_link, calibration_frame, ros::Time::now(), ros::Duration(1.0));
  listener.lookupTransform(camera_link, calibration_frame, ros::Time(0), camlink2calib);

  // Update location of AR tag
  tf::Transform targ_transform;
  tf::Quaternion targ_q;
  targ_q.setRPY(0, 0, 0);
  targ_transform.setOrigin(tf::Vector3(targ_x, targ_y, targ_z));
  targ_transform.setRotation(targ_q);

  ROS_INFO("Sending target transform.");
  target_broadcaster.sendTransform(
        tf::StampedTransform(targ_transform, ros::Time::now(), "world", "target_link"));
  ros::Duration(1.0).sleep();

  // Broadcast initial camera transform that is based on target_link
  tf::Transform transform;
  tf::Quaternion q;
  q.setRPY(0,0,0);
  transform.setOrigin(tf::Vector3(0,0,0));
  transform.setRotation(q);
  camera_broadcaster.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "target_link", calibration_frame));
  tf::StampedTransform stamped;
  ROS_INFO("Sending initial camera transform and beginning calibration.");
  ros::Duration(1.0).sleep();

  double rx = 0;
  double ry = 0;
  double rz = 0;
  double rw = 0;
  double x = 0;
  double y = 0;
  double z = 0;
  // Calibrate the camera position
  for (int ind = 0; ind < num_iterations; ind++)
  {
    target_broadcaster.sendTransform(
        tf::StampedTransform(targ_transform, ros::Time::now(), "world", "target_link"));
    try
    {
      // Get actual location of target in camera frame
      listener.lookupTransform("/ar_marker_0", calibration_frame, ros::Time(0), stamped);
      // Update location of camera based on that transform
      stamped.frame_id_ = "target_link";
      stamped.child_frame_id_ = calibration_frame;
      camera_broadcaster.sendTransform(stamped);

      // Take average
      // Note: There are better ways to average quaternions (https://stackoverflow.com/questions/12374087/average-of-multiple-quaternions)
      rx += stamped.getRotation().x()/float(num_iterations);
      ry += stamped.getRotation().y()/float(num_iterations);
      rz += stamped.getRotation().z()/float(num_iterations);
      rw += stamped.getRotation().w()/float(num_iterations);
      x += stamped.getOrigin().x()/float(num_iterations);
      y += stamped.getOrigin().y()/float(num_iterations);
      z += stamped.getOrigin().z()/float(num_iterations);
    }
    catch (tf::TransformException ex)
    {
      ROS_ERROR("%s", ex.what());
      ros::Duration(1.0).sleep();
    }

    ros::spinOnce();
    ros::Duration(0.25).sleep();
  }

  // Update location of camera based on the average transform
  stamped.frame_id_ = "target_link";
  stamped.child_frame_id_ = calibration_frame;
  stamped.setRotation(tf::Quaternion(rx,ry,rz,rw).normalize());
  stamped.setOrigin(tf::Vector3(x,y,z));
  camera_broadcaster.sendTransform(stamped);

  // We need the world to camera_link transform. Compute and save it.
  listener.lookupTransform("world", calibration_frame, ros::Time(0), stamped);
  tf::StampedTransform world2camlink;
  world2camlink.setRotation((stamped*(camlink2calib.inverse())).getRotation());
  world2camlink.setOrigin((stamped*(camlink2calib.inverse())).getOrigin());
  world2camlink.frame_id_ = "world";
  world2camlink.child_frame_id_ = camera_link;
  saveTF(world2camlink, calib_file);

}
